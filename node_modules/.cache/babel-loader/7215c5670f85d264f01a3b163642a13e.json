{"ast":null,"code":"import _slicedToArray from \"/Users/maksim/Desktop/twitter-clone/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n\nvar _s = $RefreshSig$();\n\nimport { useState, useEffect } from \"react\";\nexport default function useDebounce(value, delay) {\n  _s();\n\n  // Состояние и сеттер для отложенного значения\n  var _useState = useState(value),\n      _useState2 = _slicedToArray(_useState, 2),\n      debouncedValue = _useState2[0],\n      setDebouncedValue = _useState2[1];\n\n  useEffect(function () {\n    // Выставить debouncedValue равным value (переданное значение)\n    // после заданной задержки\n    var handler = setTimeout(function () {\n      setDebouncedValue(value);\n    }, delay); // Вернуть функцию очистки, которая будет вызываться каждый раз, когда ...\n    // ... useEffect вызван снова. useEffect будет вызван снова, только если ...\n    // ... value будет изменено (смотри ниже массив зависимостей).\n    // Так мы избегаем изменений debouncedValue, если значение value ...\n    // ... поменялось в рамках интервала задержки.\n    // Таймаут очищается и стартует снова.\n    // Что бы сложить это воедино: если пользователь печатает что-то внутри ...\n    // ... нашего приложения в поле поиска, мы не хотим, чтобы debouncedValue...\n    // ... не менялось до тех пор, пока он не прекратит печатать дольше, чем 500ms.\n\n    return function () {\n      clearTimeout(handler);\n    };\n  }, // Вызывается снова, только если значение изменится\n  // мы так же можем добавить переменную \"delay\" в массива зависимостей ...\n  // ... если вы собираетесь менять ее динамически.\n  [value]);\n  return debouncedValue;\n}\n\n_s(useDebounce, \"KDuPAtDOgxm8PU6legVJOb3oOmA=\");","map":{"version":3,"sources":["/Users/maksim/Desktop/twitter-clone/src/debouns.tsx"],"names":["useState","useEffect","useDebounce","value","delay","debouncedValue","setDebouncedValue","handler","setTimeout","clearTimeout"],"mappings":";;;;AAAA,SAAgBA,QAAhB,EAA0BC,SAA1B,QAA2C,OAA3C;AAEA,eAAe,SAASC,WAAT,CAAqBC,KAArB,EAAiCC,KAAjC,EAA6C;AAAA;;AAC1D;AAD0D,kBAEdJ,QAAQ,CAACG,KAAD,CAFM;AAAA;AAAA,MAEnDE,cAFmD;AAAA,MAEnCC,iBAFmC;;AAI1DL,EAAAA,SAAS,CACP,YAAM;AACJ;AACA;AACA,QAAMM,OAAO,GAAGC,UAAU,CAAC,YAAM;AAC/BF,MAAAA,iBAAiB,CAACH,KAAD,CAAjB;AACD,KAFyB,EAEvBC,KAFuB,CAA1B,CAHI,CAOJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,WAAO,YAAM;AACXK,MAAAA,YAAY,CAACF,OAAD,CAAZ;AACD,KAFD;AAGD,GApBM,EAqBP;AACA;AACA;AACA,GAACJ,KAAD,CAxBO,CAAT;AA2BA,SAAOE,cAAP;AACD;;GAhCuBH,W","sourcesContent":["import React, { useState, useEffect } from \"react\"\n\nexport default function useDebounce(value: any, delay: any) {\n  // Состояние и сеттер для отложенного значения\n  const [debouncedValue, setDebouncedValue] = useState(value)\n\n  useEffect(\n    () => {\n      // Выставить debouncedValue равным value (переданное значение)\n      // после заданной задержки\n      const handler = setTimeout(() => {\n        setDebouncedValue(value)\n      }, delay)\n\n      // Вернуть функцию очистки, которая будет вызываться каждый раз, когда ...\n      // ... useEffect вызван снова. useEffect будет вызван снова, только если ...\n      // ... value будет изменено (смотри ниже массив зависимостей).\n      // Так мы избегаем изменений debouncedValue, если значение value ...\n      // ... поменялось в рамках интервала задержки.\n      // Таймаут очищается и стартует снова.\n      // Что бы сложить это воедино: если пользователь печатает что-то внутри ...\n      // ... нашего приложения в поле поиска, мы не хотим, чтобы debouncedValue...\n      // ... не менялось до тех пор, пока он не прекратит печатать дольше, чем 500ms.\n      return () => {\n        clearTimeout(handler)\n      }\n    },\n    // Вызывается снова, только если значение изменится\n    // мы так же можем добавить переменную \"delay\" в массива зависимостей ...\n    // ... если вы собираетесь менять ее динамически.\n    [value]\n  )\n\n  return debouncedValue\n}\n"]},"metadata":{},"sourceType":"module"}